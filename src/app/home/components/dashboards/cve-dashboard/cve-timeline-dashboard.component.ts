import { Component, OnInit, AfterViewInit, ViewChild, ElementRef, ViewEncapsulation } from '@angular/core';
import { Router } from '@angular/router';
import * as d3 from 'd3';
import { sankey, sankeyLinkHorizontal } from 'd3-sankey';

interface TimelineEvent {
  date: string;
  sentence: string;
}

interface ProcessedEvent extends TimelineEvent {
  parsedDate: Date;
  entity: string;
  stage: string;
  impact: number;
  type: 'discovery' | 'patch' | 'exploit' | 'advisory' | 'attack';
}

@Component({
  selector: 'cve-timeline-dashboard',
  templateUrl: './cve-timeline-dashboard.component.html',
  styleUrl: './cve-timeline-dashboard.component.less',
  encapsulation: ViewEncapsulation.None
})
export class CveTimeLineDashboardComponent implements OnInit, AfterViewInit {
  @ViewChild('ganttChart') ganttChart!: ElementRef;
  @ViewChild('heatmap') heatmap!: ElementRef;
  @ViewChild('networkGraph') networkGraph!: ElementRef;
  @ViewChild('sankeyDiagram') sankeyDiagram!: ElementRef;
  @ViewChild('bubbleChart') bubbleChart!: ElementRef;
  @ViewChild('circularTimeline') circularTimeline!: ElementRef;
  @ViewChild('eventDistribution') eventDistribution!: ElementRef;
  @ViewChild('timelineProgress') timelineProgress!: ElementRef;
  @ViewChild('entityActivity') entityActivity!: ElementRef;

  activeViz = 0;
  storyPlaying = false;
  currentStoryIndex = -1;
  storyInterval: any;

  // Animation properties for circular timeline
  isAnimating = false;
  animationSpeed = 1000; // milliseconds per step
  currentAnimationDate: Date | null = null;
  animationInterval: any;
  animationStartDate: Date | null = null;
  animationEndDate: Date | null = null;

  visualizations = [
    { name: 'Gantt Chart' },
    { name: 'Activity Heatmap' },
    { name: 'Network Graph' },
    { name: 'Sankey Diagram' },
    { name: 'Story Map' },
    { name: 'Bubble Chart' },
    { name: 'Metro Map' },
    { name: 'Kanban Board' },
    { name: 'Circular Timeline' },
    { name: 'Dashboard' }
  ];

  private defaultEvents: TimelineEvent[] = [
    {
      date: "April 8, 2022",
      sentence: `The vulnerability was assigned the identifier CVE-2022-28810 by <mark>MITRE Corporation</mark>.<br/><br/>`
    },
    {
      date: "April 9, 2022",
      sentence: `<mark>ManageEngine</mark> released build 6122 of ADSelfService Plus to fix the vulnerability. The update removed the "custom script" feature that was being exploited.<br/><br/>`
    },
    {
      date: "April 14, 2022",
      sentence: `<mark>Rapid7</mark>, a cybersecurity company, published a blog post detailing the vulnerability.<br/><br/>`
    },
    {
      date: "April 18, 2022",
      sentence: `The vulnerability was published on the <mark>National Vulnerability Database (NVD)</mark>.<br/><br/>`
    },
    {
      date: "April 19, 2022",
      sentence: `A video was posted on <mark>YouTube</mark> demonstrating how to exploit the vulnerability using Metasploit, a penetration testing software.<br/><br/>`
    },
    {
      date: "April 21, 2022",
      sentence: `<mark>Packet Storm</mark>, a network security community, published a Metasploit module that exploits the "custom script" feature of ADSelfService Plus.<br/><br/>`
    },
    {
      date: "October 2022",
      sentence: `CVE-2022-47966 was discovered by <mark>Khoadha</mark> of Viettel Cyber Security and patched for the affected products.<br /><br />`
    },
    {
      date: "January 10, 2023",
      sentence: `<mark>ManageEngine</mark> released a security advisory for this issue.<br /><br />`
    },
    {
      date: "January 18, 2023",
      sentence: `The vulnerability was published on <mark>NVD</mark>.<br/>Researchers at <mark>Horizon3ai</mark> released a technical deep dive and a proof of concept (PoC) for this issue.<br /><br />`
    },
    {
      date: "January 19, 2023",
      sentence: `<mark>Horizon.ai</mark> released an in-depth technical overview of the CVE-2022-47966 alongside the PoC exploit for it. Simultaneously, <mark>Rapid7</mark> researchers reported several related compromises observed since at least January 17.<br /><br />`
    },
    {
      date: "January 2023",
      sentence: `Multiple nation-state advanced persistent threat <mark>(APT) actors</mark> exploited CVE-2022-47966 to access an organization's web server hosting the public-facing application, Zoho ManageEngine ServiceDesk Plus.<br/><br/>`
    },
    {
      date: "February 1, 2023",
      sentence: `<mark>Rapid7</mark> provided a detailed description of the vulnerability.<br/><br/>`
    },
    {
      date: "March 8, 2023",
      sentence: `<mark>CISA</mark> added CVE-2022-28810 to KEV.<br/><br/>`
    },
    {
      date: "March 15, 2023",
      sentence: `<mark>GreyNoise</mark> publishes tags for both CVEs.<br/><br/>`
    },
    {
      date: "September 7, 2023",
      sentence: `<mark>CISA</mark>, the Federal Bureau of Investigation (<mark>FBI</mark>), and the Cyber National Mission Force (<mark>CNMF</mark>) identified the presence of indicators of compromise (IOCs) at an Aeronautical Sector organization.<br/><br/>`
    }
  ];

  processedEvents: ProcessedEvent[] = [];
  kanbanStages: any[] = [];
  totalEvents = 0;
  uniqueEntities = 0;
  timespan = 0;

  ngOnInit() {
    this.processEvents();
    this.setupKanbanBoard();
    this.calculateMetrics();
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.renderVisualization();
    }, 100);
  }

  processEvents() {
    this.processedEvents = this.defaultEvents.map(event => {
      const parsedDate = new Date(event.date);
      const entity = this.extractEntity(event.sentence);
      const stage = this.determineStage(event.sentence);
      const impact = this.calculateImpact(event.sentence);
      const type = this.determineType(event.sentence);

      return {
        ...event,
        parsedDate,
        entity,
        stage,
        impact,
        type
      };
    }).sort((a, b) => a.parsedDate.getTime() - b.parsedDate.getTime());
  }

  extractEntity(sentence: string): string {
    const match = sentence.match(/<mark>(.*?)<\/mark>/);
    return match ? match[1] : 'Unknown';
  }

  determineStage(sentence: string): string {
    if (sentence.includes('discovered') || sentence.includes('assigned')) return 'Discovery';
    if (sentence.includes('released') || sentence.includes('patched')) return 'Mitigation';
    if (sentence.includes('exploit') || sentence.includes('PoC')) return 'Exploitation';
    if (sentence.includes('advisory') || sentence.includes('published')) return 'Disclosure';
    if (sentence.includes('attack') || sentence.includes('compromise')) return 'Attack';
    return 'Other';
  }

  calculateImpact(sentence: string): number {
    let impact = 1;
    if (sentence.includes('nation-state') || sentence.includes('APT')) impact += 3;
    if (sentence.includes('exploit') || sentence.includes('attack')) impact += 2;
    if (sentence.includes('PoC') || sentence.includes('Metasploit')) impact += 2;
    if (sentence.includes('CISA') || sentence.includes('FBI')) impact += 1;
    return Math.min(impact, 5);
  }

  determineType(sentence: string): 'discovery' | 'patch' | 'exploit' | 'advisory' | 'attack' {
    if (sentence.includes('discovered') || sentence.includes('assigned')) return 'discovery';
    if (sentence.includes('released') || sentence.includes('patched')) return 'patch';
    if (sentence.includes('exploit') || sentence.includes('PoC')) return 'exploit';
    if (sentence.includes('advisory') || sentence.includes('published')) return 'advisory';
    if (sentence.includes('attack') || sentence.includes('compromise')) return 'attack';
    return 'advisory';
  }

  setupKanbanBoard() {
    const stages = ['Discovery', 'Disclosure', 'Mitigation', 'Exploitation', 'Attack'];
    this.kanbanStages = stages.map(stage => ({
      name: stage,
      events: this.processedEvents.filter(event => event.stage === stage)
    }));
  }

  calculateMetrics() {
    this.totalEvents = this.processedEvents.length;
    this.uniqueEntities = new Set(this.processedEvents.map(e => e.entity)).size;
    const dates = this.processedEvents.map(e => e.parsedDate);
    const minDate = new Date(Math.min(...dates.map(d => d.getTime())));
    const maxDate = new Date(Math.max(...dates.map(d => d.getTime())));
    this.timespan = Math.ceil((maxDate.getTime() - minDate.getTime()) / (1000 * 60 * 60 * 24));
  }

  setActiveViz(index: number) {
    this.activeViz = index;
    setTimeout(() => {
      this.renderVisualization();
    }, 100);
  }

  renderVisualization() {
    switch (this.activeViz) {
      case 0: this.renderGanttChart(); break;
      case 1: this.renderHeatmap(); break;
      case 2: this.renderNetworkGraph(); break;
      case 3: this.renderSankeyDiagram(); break;
      case 5: this.renderBubbleChart(); break;
      case 8: this.renderCircularTimeline(); break;
      case 9: this.renderDashboard(); break;
    }
  }

  constructor(private router: Router) { }

  goHome(): void {
    this.router.navigate(['/']);
  }

  // Update the renderGanttChart method
  renderGanttChart() {
    if (!this.ganttChart) return;

    const container = d3.select(this.ganttChart.nativeElement);
    container.selectAll("*").remove();

    const margin = { top: 20, right: 30, bottom: 40, left: 120 };
    const width = 800 - margin.left - margin.right;
    const height = 400 - margin.bottom - margin.top;

    const svg = container.append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top - 20})`);

    const xScale = d3.scaleTime()
      .domain(d3.extent(this.processedEvents, d => d.parsedDate) as [Date, Date])
      .range([0, width]);

    const yScale = d3.scaleBand()
      .domain(this.processedEvents.map((d, i) => d.entity))
      .range([0, height])
      .padding(0.1);

    const colorScale = d3.scaleOrdinal()
      .domain(['discovery', 'patch', 'exploit', 'advisory', 'attack'])
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    // Add tooltip div
    const tooltip = d3.select(this.ganttChart.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    // Add bars with hover effects
    g.selectAll('.bar')
      .data(this.processedEvents)
      .enter().append('rect')
      .attr('class', 'bar')
      .attr('x', d => xScale(d.parsedDate))
      .attr('y', d => yScale(d.entity)!)
      .attr('width', 20)
      .attr('height', yScale.bandwidth())
      .attr('fill', d => colorScale(d.type) as string)
      .attr('opacity', 0.8)
      .on('mouseover', (event, d) => {

        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
        <strong>${d.entity}</strong><br/>
        Date: ${d.date}<br/>
        Type: ${d.type}<br/>
        Impact: ${d.impact}/5<br/>
        ${d.sentence.replace(/<br\/>/g, '')}
      `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');

        d3.select(event.currentTarget)
          .attr('opacity', 1)
          .attr('stroke', '#333')
          .attr('stroke-width', 2);
      })
      .on('mouseout', (event, d) => {
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('opacity', 0.8)
          .attr('stroke', 'none');
      });

    // Add axes
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(xScale)).selectAll('text')
      .attr('transform', 'rotate(-45)')
      .style('text-anchor', 'end');

    g.append('g')
      .call(d3.axisLeft(yScale));
  }

  // Update the renderHeatmap method
  renderHeatmap() {
    if (!this.heatmap) return;

    const container = d3.select(this.heatmap.nativeElement);
    container.selectAll("*").remove();

    // Create a GitHub-style heatmap
    const cellSize = 15;
    const yearStart = new Date(2022, 0, 1);
    const yearEnd = new Date(2023, 11, 31);

    const svg = container.append('svg')
      .attr('width', 800)
      .attr('height', 200);

    const g = svg.append('g')
      .attr('transform', 'translate(40,20)');

    // Create data for each day
    const dayData = d3.timeDays(yearStart, yearEnd).map(day => {
      const eventsOnDay = this.processedEvents.filter(e =>
        e.parsedDate.toDateString() === day.toDateString()
      );
      return {
        date: day,
        count: eventsOnDay.length,
        events: eventsOnDay
      };
    });

    const colorScale = d3.scaleSequential()
      .domain([0, d3.max(dayData, d => d.count) || 1])
      .interpolator(d3.interpolateBlues);

    // Add tooltip
    const tooltip = d3.select(this.heatmap.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    g.selectAll('.day')
      .data(dayData)
      .enter().append('rect')
      .attr('class', 'day')
      .attr('width', cellSize)
      .attr('height', cellSize)
      .attr('x', d => d3.timeWeek.count(yearStart, d.date) * cellSize)
      .attr('y', d => d.date.getDay() * cellSize)
      .attr('fill', d => d.count > 0 ? colorScale(d.count) : '#eee')
      .attr('stroke', '#fff')
      .attr('stroke-width', 1)
      .on('mouseover', (event, d) => {
        if (d.count > 0) {
          tooltip.transition()
            .duration(200)
            .style('opacity', 1);
          tooltip.html(`
          <strong>${d3.timeFormat('%B %d, %Y')(d.date)}</strong><br/>
          Events: ${d.count}<br/>
          ${d.events.map(e => `• ${e.entity}: ${e.type}`).join('<br/>')}
        `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');

          d3.select(event.currentTarget)
            .attr('stroke', '#333')
            .attr('stroke-width', 2);
        }
      })
      .on('mouseout', (event, d) => {
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('stroke', '#fff')
          .attr('stroke-width', 1);
      });
  }

  // Update the renderNetworkGraph method
  renderNetworkGraph() {
    if (!this.networkGraph) return;

    const container = d3.select(this.networkGraph.nativeElement);
    container.selectAll("*").remove();

    const width = 800;
    const height = 500;

    // Create nodes and links
    const entities = Array.from(new Set(this.processedEvents.map(e => e.entity)));
    const nodes = entities.map(entity => ({
      id: entity,
      group: this.processedEvents.find(e => e.entity === entity)?.type || 'unknown'
    }));

    const links: any[] = [];
    this.processedEvents.forEach((event, i) => {
      if (i < this.processedEvents.length - 1) {
        links.push({
          source: event.entity,
          target: this.processedEvents[i + 1].entity,
          value: 1
        });
      }
    });

    const svg = container.append('svg')
      .attr('width', width)
      .attr('height', height);

    // Add tooltip
    const tooltip = d3.select(this.networkGraph.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    const simulation = d3.forceSimulation(nodes as any)
      .force('link', d3.forceLink(links).id((d: any) => d.id))
      .force('charge', d3.forceManyBody().strength(-300))
      .force('center', d3.forceCenter(width / 2, height / 2));

    const colorScale = d3.scaleOrdinal()
      .domain(['discovery', 'patch', 'exploit', 'advisory', 'attack'])
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    const link = svg.append('g')
      .selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('stroke', '#999')
      .attr('stroke-opacity', 0.6)
      .attr('stroke-width', 2);

    const node = svg.append('g')
      .selectAll('circle')
      .data(nodes)
      .enter().append('circle')
      .attr('r', 8)
      .attr('fill', (d: any) => colorScale(d.group) as string)
      .on('mouseover', (event, d: any) => {
        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
        <strong>${d.id}</strong><br/>
        Type: ${d.group}<br/>
        Events: ${this.processedEvents.filter(e => e.entity === d.id).length}
      `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');

        d3.select(event.currentTarget)
          .attr('r', 12)
          .attr('stroke', '#333')
          .attr('stroke-width', 2);
      })
      .on('mouseout', (event, d) => {
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('r', 8)
          .attr('stroke', 'none');
      })
      .call(d3.drag<any, any>()
        .on('start', (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on('end', (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }));

    const label = svg.append('g')
      .selectAll('text')
      .data(nodes)
      .enter().append('text')
      .text((d: any) => d.id)
      .attr('font-size', 10)
      .attr('dx', 12)
      .attr('dy', 4);

    simulation.on('tick', () => {
      link
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      node
        .attr('cx', (d: any) => d.x)
        .attr('cy', (d: any) => d.y);

      label
        .attr('x', (d: any) => d.x)
        .attr('y', (d: any) => d.y);
    });
  }

  // Update the renderSankeyDiagram method
  /*   renderSankeyDiagram() {
      if (!this.sankeyDiagram) return;
  
      const container = d3.select(this.sankeyDiagram.nativeElement);
      container.selectAll("*").remove();
  
      const width = 800;
      const height = 500;
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
  
      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);
  
      const stages = ['Discovery', 'Disclosure', 'Mitigation', 'Exploitation', 'Attack'];
      const nodes = stages.map((stage, i) => ({
        name: stage,
        x: i * (width / (stages.length - 1)),
        y: height / 2
      }));
  
      const links = [];
      for (let i = 0; i < stages.length - 1; i++) {
        links.push({
          source: i,
          target: i + 1,
          value: this.processedEvents.filter(e => e.stage === stages[i]).length
        });
      }
  
      const colorScale = d3.scaleOrdinal()
        .domain(stages)
        .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);
  
      // Add tooltip
      const tooltip = d3.select(this.sankeyDiagram.nativeElement).append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute')
        .style('background', 'white')
        .style('padding', '8px')
        .style('border', '1px solid #ddd')
        .style('border-radius', '4px')
        .style('pointer-events', 'none');
  
      // Draw links with hover
      svg.selectAll('.link')
        .data(links)
        .enter().append('path')
        .attr('class', 'link')
        .attr('d', (d3.linkVertical() as any)
          .source((d: any) => ({ x: nodes[d.source].x, y: nodes[d.source].y }))
          .target((d: any) => ({ x: nodes[d.target].x, y: nodes[d.target].y }))
        )
        .attr('stroke', (d: any) => colorScale(stages[d.source]) as string)
        .attr('stroke-width', (d: any) => Math.sqrt(d.value) * 5)
        .attr('fill', 'none')
        .on('mouseover', (event, d: any) => {
          tooltip.transition()
            .duration(200)
            .style('opacity', 1);
          tooltip.html(`
          <strong>${stages[d.source]} → ${stages[d.target]}</strong><br/>
          Events: ${d.value}
        `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
  
          d3.select(event.currentTarget)
            .attr('stroke-width', (d: any) => Math.sqrt(d.value) * 8);
        })
        .on('mouseout', (event, d) => {
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
  
          d3.select(event.currentTarget)
            .attr('stroke-width', (d: any) => Math.sqrt(d.value) * 5);
        });
  
      // Draw nodes with hover
      svg.selectAll('.node')
        .data(nodes)
        .enter().append('circle')
        .attr('class', 'node')
        .attr('cx', (d: any) => d.x)
        .attr('cy', (d: any) => d.y)
        .attr('r', 10)
        .attr('fill', (d: any) => colorScale(d.name) as string)
        .on('mouseover', (event, d: any) => {
          tooltip.transition()
            .duration(200)
            .style('opacity', 1);
          tooltip.html(`
          <strong>${d.name}</strong><br/>
          Events: ${this.processedEvents.filter(e => e.stage === d.name).length}
        `)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
  
          d3.select(event.currentTarget)
            .attr('r', 15);
        })
        .on('mouseout', (event, d) => {
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
  
          d3.select(event.currentTarget)
            .attr('r', 10);
        });
  
      // Add labels
      svg.selectAll('.label')
        .data(nodes)
        .enter().append('text')
        .attr('class', 'label')
        .attr('x', (d: any) => d.x)
        .attr('y', (d: any) => d.y + 25)
        .attr('text-anchor', 'middle')
        .text((d: any) => d.name)
        .attr('fill', '#333');
    } */

  renderSankeyDiagram() {
    if (!this.sankeyDiagram) return;

    const container = d3.select(this.sankeyDiagram.nativeElement);
    container.selectAll("*").remove();

    const width = 800;
    const height = 500;
    const margin = { top: 20, right: 150, bottom: 20, left: 150 };

    const svg = container.append('svg')
      .attr('width', width)
      .attr('height', height)
      .append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    const stages = ['Discovery', 'Disclosure', 'Mitigation', 'Exploitation', 'Attack'];

    // Count events for each stage
    const stageCounts = stages.map(stage =>
      this.processedEvents.filter(e => e.stage === stage).length
    );

    // Create nodes array
    const nodes: any[] = stages.map(stage => ({ name: stage }));

    // Create links between consecutive stages
    const links: any[] = [];
    for (let i = 0; i < stages.length - 1; i++) {
      const value = Math.max(stageCounts[i], 1);
      links.push({
        source: i,
        target: i + 1,
        value: value
      });
    }

    // Create Sankey generator using the imported function
    const sankeyGenerator = sankey()
      .nodeWidth(20)
      .nodePadding(60)
      .extent([[0, 0], [innerWidth, innerHeight]]);

    // Generate the graph
    const graph: any = sankeyGenerator({
      nodes: nodes.map(d => ({ ...d })),
      links: links.map(d => ({ ...d }))
    });

    const colorScale = d3.scaleOrdinal()
      .domain(stages)
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    // Tooltip
    const tooltip = container
      .append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '10px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none')
      .style('box-shadow', '0 2px 8px rgba(0,0,0,0.15)')
      .style('font-size', '12px')
      .style('z-index', '1000');

    // Create the link path generator
    const linkPath = sankeyLinkHorizontal();

    // Draw links
    const linkGroup = svg.append('g')
      .attr('class', 'links')
      .attr('fill', 'none')
      .attr('stroke-opacity', 0.5);

    linkGroup.selectAll('path')
      .data(graph.links)
      .enter()
      .append('path')
      .attr('d', (d: any) => linkPath(d) as string)
      .attr('stroke', (d: any) => colorScale(d.source.name) as string)
      .attr('stroke-width', (d: any) => Math.max(1, d.width))
      .style('cursor', 'pointer')
      .on('mouseover', function (event, d: any) {
        d3.select(this)
          .attr('stroke-opacity', 0.8);

        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
                <strong>${d.source.name} → ${d.target.name}</strong><br/>
                Flow: ${d.value} events
              `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', function () {
        d3.select(this)
          .attr('stroke-opacity', 0.5);

        tooltip.transition()
          .duration(500)
          .style('opacity', 0);
      });

    // Draw nodes
    const nodeGroup = svg.append('g')
      .attr('class', 'nodes');

    nodeGroup.selectAll('rect')
      .data(graph.nodes)
      .enter()
      .append('rect')
      .attr('x', (d: any) => d.x0)
      .attr('y', (d: any) => d.y0)
      .attr('height', (d: any) => d.y1 - d.y0)
      .attr('width', (d: any) => d.x1 - d.x0)
      .attr('fill', (d: any) => colorScale(d.name) as string)
      .attr('opacity', 0.9)
      .style('cursor', 'pointer')
      .on('mouseover', function (event, d: any) {
        d3.select(this).attr('opacity', 1);

        const eventCount = stageCounts[stages.indexOf(d.name)];

        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
                <strong>${d.name}</strong><br/>
                Events: ${eventCount}
              `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', function () {
        d3.select(this).attr('opacity', 0.9);

        tooltip.transition()
          .duration(500)
          .style('opacity', 0);
      });

    // Add stage labels
    nodeGroup.selectAll('text.stage-label')
      .data(graph.nodes)
      .enter()
      .append('text')
      .attr('class', 'stage-label')
      .attr('x', (d: any) => d.x0 < innerWidth / 2 ? d.x1 + 6 : d.x0 - 6)
      .attr('y', (d: any) => (d.y1 + d.y0) / 2)
      .attr('dy', '0.35em')
      .attr('text-anchor', (d: any) => d.x0 < innerWidth / 2 ? 'start' : 'end')
      .text((d: any) => d.name)
      .attr('font-size', '14px')
      .attr('font-weight', '600')
      .attr('fill', '#333');

    // Add event counts
    nodeGroup.selectAll('text.count-label')
      .data(graph.nodes)
      .enter()
      .append('text')
      .attr('class', 'count-label')
      .attr('x', (d: any) => d.x0 < innerWidth / 2 ? d.x1 + 6 : d.x0 - 6)
      .attr('y', (d: any) => (d.y1 + d.y0) / 2 + 16)
      .attr('dy', '0.35em')
      .attr('text-anchor', (d: any) => d.x0 < innerWidth / 2 ? 'start' : 'end')
      .text((d: any) => `(${stageCounts[stages.indexOf(d.name)]})`)
      .attr('font-size', '11px')
      .attr('fill', '#666');
  }

  // Update the renderBubbleChart method
  renderBubbleChart() {
    if (!this.bubbleChart) return;

    const container = d3.select(this.bubbleChart.nativeElement);
    container.selectAll("*").remove();

    const width = 800;
    const height = 500;
    const margin = { top: 20, right: 20, bottom: 50, left: 50 };

    const svg = container.append('svg')
      .attr('viewBox', [0, -10, width * 1.2, height * 1.2].join(' '))
      .attr('width', width)
      .attr('height', height);

    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleTime()
      .domain(d3.extent(this.processedEvents, d => d.parsedDate) as [Date, Date])
      .range([0, width - margin.left - margin.right]);

    const yScale = d3.scaleLinear()
      .domain([0, 5])
      .range([height - margin.top - margin.bottom, 0]);

    const rScale = d3.scaleLinear()
      .domain([0, 5])
      .range([5, 30]);

    const colorScale = d3.scaleOrdinal()
      .domain(['discovery', 'patch', 'exploit', 'advisory', 'attack'])
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    // Add tooltip
    const tooltip = d3.select(this.bubbleChart.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    // Add bubbles with hover effects
    g.selectAll('.bubble')
      .data(this.processedEvents)
      .enter().append('circle')
      .attr('class', 'bubble')
      .attr('cx', (d: any) => xScale(d.parsedDate))
      .attr('cy', (d: any) => yScale(d.impact))
      .attr('r', (d: any) => rScale(d.impact))
      .attr('fill', (d: any) => colorScale(d.type) as string)
      .attr('opacity', 0.7)
      .attr('stroke', '#fff')
      .attr('stroke-width', 1)
      .on('mouseover', (event, d) => {
        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
        <strong>${d.entity}</strong><br/>
        Date: ${d.date}<br/>
        Type: ${d.type}<br/>
        Impact: ${d.impact}/5<br/>
        ${d.sentence.replace(/<br\/>/g, '')}
      `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');

        d3.select(event.currentTarget)
          .attr('opacity', 1)
          .attr('stroke', '#333')
          .attr('stroke-width', 2);
      })
      .on('mouseout', (event, d) => {
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('opacity', 0.7)
          .attr('stroke', '#fff')
          .attr('stroke-width', 1);
      });

    // Add axes
    g.append('g')
      .attr('transform', `translate(0,${height - margin.top - margin.bottom})`)
      .call(d3.axisBottom(xScale)).selectAll('text')
      .attr('transform', 'rotate(-45)')
      .style('text-anchor', 'end');

    g.append('g')
      .call(d3.axisLeft(yScale));

    // Add labels
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', height - 5)
      .attr('text-anchor', 'middle')
      .text('Date');

    svg.append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', 15)
      .attr('text-anchor', 'middle')
      .text('Impact');
  }

  // Update the renderCircularTimeline method
  renderCircularTimeline() {
    if (!this.circularTimeline) return;

    const container = d3.select(this.circularTimeline.nativeElement);
    container.selectAll("*").remove();

    const width = 800;
    const height = 600;
    const radius = Math.min(width, height) / 2 - 40;

    const svg = container.append('svg')
      .attr('viewBox', [0, -10, width * 1, height * 1].join(' '))
      .attr('width', width)
      .attr('height', height)
      .append('g')
      .attr('transform', `translate(${width / 2},${height / 2})`);

    // Filter events based on current animation date
    let eventsToShow = this.processedEvents;
    if (this.currentAnimationDate) {
      eventsToShow = this.processedEvents.filter(event =>
        event.parsedDate <= this.currentAnimationDate!
      );
    }

    const timeExtent = d3.extent(this.processedEvents, d => d.parsedDate) as [Date, Date];
    const angleScale = d3.scaleTime()
      .domain(timeExtent)
      .range([0, 2 * Math.PI]);

    const radiusScale = d3.scaleLinear()
      .domain([0, 5])
      .range([radius * 0.5, radius]);

    const colorScale = d3.scaleOrdinal()
      .domain(['discovery', 'patch', 'exploit', 'advisory', 'attack'])
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    // Add tooltip
    const tooltip = d3.select(this.circularTimeline.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    // Draw the circle
    svg.append('circle')
      .attr('r', radius)
      .attr('fill', 'none')
      .attr('stroke', '#ddd')
      .attr('stroke-width', 1);

    // Create collision detection system
    const positions: Array<{ x: number, y: number, radius: number }> = [];

    const checkCollision = (x: number, y: number, r: number = 8): boolean => {
      return positions.some(pos => {
        const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
        return distance < (r + pos.radius + 4); // 4px minimum spacing
      });
    };

    const findValidPosition = (originalX: number, originalY: number, r: number = 8): { x: number, y: number } => {
      let attempts = 0;
      let maxAttempts = 50;
      let spiralRadius = 15;
      let angle = 0;

      while (attempts < maxAttempts) {
        let testX = originalX + spiralRadius * Math.cos(angle);
        let testY = originalY + spiralRadius * Math.sin(angle);

        // Keep within the circular bounds
        const distanceFromCenter = Math.sqrt(testX ** 2 + testY ** 2);
        if (distanceFromCenter > radius - 20) {
          // If outside bounds, move inward
          const scale = (radius - 20) / distanceFromCenter;
          testX *= scale;
          testY *= scale;
        }

        if (!checkCollision(testX, testY, r)) {
          return { x: testX, y: testY };
        }

        // Spiral outward
        angle += 0.5;
        if (angle > 2 * Math.PI) {
          angle = 0;
          spiralRadius += 8;
        }
        attempts++;
      }

      // Fallback to original position if no valid position found
      return { x: originalX, y: originalY };
    };

    // Add events with collision avoidance
    eventsToShow.forEach((eventData, i) => {
      const angle = angleScale(eventData.parsedDate);
      const r = radiusScale(eventData.impact);
      const originalX = r * Math.sin(angle);
      const originalY = -r * Math.cos(angle);

      // Find a position that doesn't overlap
      const position = findValidPosition(originalX, originalY, 8);
      const { x, y } = position;

      // Store the position for future collision detection
      positions.push({ x, y, radius: 8 });

      // Create circle with improved hover effects and animation
      const circle = svg.append('circle')
        .attr('cx', x)
        .attr('cy', y)
        .attr('r', 0) // Start with radius 0 for animation
        .attr('fill', colorScale(eventData.type) as string)
        .attr('stroke', '#fff')
        .attr('stroke-width', 2)
        .style('cursor', 'pointer')
        .style('opacity', 0) // Start invisible
        .on('mouseover', (mouseEvent: MouseEvent) => {
          tooltip.transition()
            .duration(200)
            .style('opacity', 1);
          tooltip.html(`
            <strong>${eventData.entity}</strong><br/>
            Date: ${eventData.date}<br/>
            Type: ${eventData.type}<br/>
            Impact: ${eventData.impact}/5<br/>
            ${eventData.sentence ? eventData.sentence.replace(/<br\/>/g, '') : ''}
          `)
            .style('left', `${mouseEvent.pageX + 10}px`)
            .style('top', `${mouseEvent.pageY - 28}px`);

          d3.select(mouseEvent.currentTarget as SVGCircleElement)
            .transition()
            .duration(200)
            .attr('r', 12)
            .attr('stroke', '#333')
            .attr('stroke-width', 3);
        })
        .on('mouseout', (mouseEvent: MouseEvent) => {
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);

          d3.select(mouseEvent.currentTarget as SVGCircleElement)
            .transition()
            .duration(200)
            .attr('r', 8)
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);
        });

      // Add animation transition
      circle.transition()
        .duration(800)
        .delay(i * 50) // Stagger the animation
        .attr('r', 8)
        .style('opacity', 1);

      // Add connecting line from original position to adjusted position (if moved significantly)
      const distance = Math.sqrt((x - originalX) ** 2 + (y - originalY) ** 2);
      if (distance > 10) {
        svg.append('line')
          .attr('x1', originalX)
          .attr('y1', originalY)
          .attr('x2', x)
          .attr('y2', y)
          .attr('stroke', colorScale(eventData.type) as string)
          .attr('stroke-width', 1)
          .attr('stroke-dasharray', '2,2')
          .attr('opacity', 0.5);
      }

      // Add text label with better positioning
      const textOffset = 15;
      const textX = x + textOffset * Math.sign(x || 1);
      const textY = y + 5;

      svg.append('text')
        .attr('x', textX)
        .attr('y', textY)
        .text(eventData.entity)
        .attr('font-size', 10)
        .attr('fill', '#333')
        .attr('text-anchor', x > 0 ? 'start' : 'end')
        .style('pointer-events', 'none')
        .style('user-select', 'none');
    });

    // Add month markers
    const months = d3.timeMonths(timeExtent[0], timeExtent[1]);
    months.forEach(month => {
      const angle = angleScale(month);
      const x1 = (radius + 10) * Math.sin(angle);
      const y1 = -(radius + 10) * Math.cos(angle);
      const x2 = (radius + 20) * Math.sin(angle);
      const y2 = -(radius + 20) * Math.cos(angle);

      svg.append('line')
        .attr('x1', x1)
        .attr('y1', y1)
        .attr('x2', x2)
        .attr('y2', y2)
        .attr('stroke', '#999')
        .attr('stroke-width', 1);

      svg.append('text')
        .attr('x', x2 + 15 * Math.sign(x2 || 1))
        .attr('y', y2 + 5)
        .text(d3.timeFormat('%b %Y')(month))
        .attr('font-size', 10)
        .attr('fill', '#666')
        .attr('text-anchor', x2 > 0 ? 'start' : 'end');
    });

    // Add legend
    const legend = svg.append('g')
      // .attr('transform', `translate(${-radius + 20}, ${-radius + 20})`);
      .attr('transform', `translate(${width - 500}, ${-radius + 20})`); // Far right

    const legendData = [
      { type: 'discovery', label: 'Discovery' },
      { type: 'patch', label: 'Patch' },
      { type: 'exploit', label: 'Exploit' },
      { type: 'advisory', label: 'Advisory' },
      { type: 'attack', label: 'Attack' }
    ];

    legendData.forEach((item, i) => {
      const legendItem = legend.append('g')
        .attr('transform', `translate(0, ${i * 20})`);

      legendItem.append('circle')
        .attr('r', 6)
        .attr('fill', colorScale(item.type) as string)
        .attr('stroke', '#fff')
        .attr('stroke-width', 1);

      legendItem.append('text')
        .attr('x', 12)
        .attr('y', 5)
        .text(item.label)
        .attr('font-size', 12)
        .attr('fill', '#333');
    });
  }

  // Update the renderDashboard method
  renderDashboard() {
    if (!this.eventDistribution || !this.timelineProgress || !this.entityActivity) return;

    // Event Distribution Chart (Pie)
    const eventDistContainer = d3.select(this.eventDistribution.nativeElement);
    eventDistContainer.selectAll("*").remove();

    const eventTypes = d3.rollups(
      this.processedEvents,
      v => v.length,
      d => d.type
    ) as any;

    const eventDistWidth = 200;
    const eventDistHeight = 200;
    const radius = Math.min(eventDistWidth, eventDistHeight) / 2;

    const eventDistSvg = eventDistContainer.append('svg')
      .attr('width', eventDistWidth)
      .attr('height', eventDistHeight)
      .append('g')
      .attr('transform', `translate(${eventDistWidth / 2},${eventDistHeight / 2})`);

    const colorScale = d3.scaleOrdinal()
      .domain(['discovery', 'patch', 'exploit', 'advisory', 'attack'])
      .range(['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336']);

    const pie = d3.pie()
      .value((d: any) => d[1]);

    const arc = d3.arc()
      .innerRadius(0)
      .outerRadius(radius);

    // Add tooltip
    const tooltip = d3.select(this.eventDistribution.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    const arcs = eventDistSvg.selectAll('path')
      .data(pie(eventTypes))
      .enter().append('path')
      .attr('d', arc as any)
      .attr('fill', (d: any) => colorScale(d.data[0]) as string)
      .attr('stroke', '#fff')
      .attr('stroke-width', 1)
      .on('mouseover', (event, d: any) => {
        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        tooltip.html(`
        <strong>${d.data[0]}</strong><br/>
        Count: ${d.data[1]}<br/>
        ${((d.data[1] / this.processedEvents.length) * 100).toFixed(1)}% of total
      `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');

        d3.select(event.currentTarget)
          .attr('stroke', '#333')
          .attr('stroke-width', 2);
      })
      .on('mouseout', (event, d) => {
        tooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('stroke', '#fff')
          .attr('stroke-width', 1);
      });

    // Timeline Progress Chart (Line)
    const timelineContainer = d3.select(this.timelineProgress.nativeElement);
    timelineContainer.selectAll("*").remove();

    const timelineWidth = 300;
    const timelineHeight = 250;
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };

    const timelineSvg = timelineContainer.append('svg')
      .attr('width', timelineWidth)
      .attr('height', timelineHeight);

    const g = timelineSvg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top - 20})`);

    const xScale = d3.scaleTime()
      .domain(d3.extent(this.processedEvents, d => d.parsedDate) as [Date, Date])
      .range([0, timelineWidth - margin.left - margin.right]);

    const yScale = d3.scaleLinear()
      .range([timelineHeight - margin.top - margin.bottom, 0]);

    // Compute cumulative count
    const cumulativeData = this.processedEvents
      .sort((a, b) => a.parsedDate.getTime() - b.parsedDate.getTime())
      .map((d, i) => ({
        date: d.parsedDate,
        count: i + 1
      }));

    yScale.domain([0, this.processedEvents.length]);

    const line = d3.line()
      .x((d: any) => xScale(d.date))
      .y((d: any) => yScale(d.count));

    // Add tooltip
    const timelineTooltip = d3.select(this.timelineProgress.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    // Add invisible rectangles for hover
    g.selectAll('.hover-rect')
      .data(cumulativeData)
      .enter().append('rect')
      .attr('class', 'hover-rect')
      .attr('x', d => xScale(d.date) - 5)
      .attr('y', 0)
      .attr('width', 10)
      .attr('height', timelineHeight - margin.top - margin.bottom)
      .attr('opacity', 0)
      .on('mouseover', (event, d: any) => {
        timelineTooltip.transition()
          .duration(200)
          .style('opacity', 1);
        timelineTooltip.html(`
        <strong>${d3.timeFormat('%B %d, %Y')(d.date)}</strong><br/>
        Cumulative events: ${d.count}
      `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', (event, d) => {
        timelineTooltip.transition()
          .duration(500)
          .style('opacity', 0);
      });

    g.append('path')
      .datum(cumulativeData)
      .attr('fill', 'none')
      .attr('stroke', '#007acc')
      .attr('stroke-width', 2)
      .attr('d', line as any);

    g.append('g')
      .attr('transform', `translate(0,${timelineHeight - margin.top - margin.bottom})`)
      .call(d3.axisBottom(xScale).ticks(3));

    g.append('g')
      .call(d3.axisLeft(yScale).ticks(5));

    // Entity Activity Chart (Bar)
    const entityContainer = d3.select(this.entityActivity.nativeElement);
    entityContainer.selectAll("*").remove();

    const entityWidth = 240;
    const entityHeight = 240;
    const entityMargin = { top: 20, right: 20, bottom: 40, left: 40 };

    const entitySvg = entityContainer.append('svg')
      .attr('width', entityWidth)
      .attr('height', entityHeight);

    const entityG = entitySvg.append('g')
      .attr('transform', `translate(${entityMargin.left},${entityMargin.top - 25})`);

    const entities = d3.rollups(
      this.processedEvents,
      v => v.length,
      d => d.entity
    ).sort((a, b) => b[1] - a[1])
    // .slice(0, 5);

    const entityXScale = d3.scaleBand()
      .domain(entities.map(d => d[0]))
      .range([0, entityWidth - entityMargin.left - entityMargin.right])
      .padding(0.2);

    const entityYScale = d3.scaleLinear()
      .domain([0, d3.max(entities, d => d[1]) || 1])
      .range([entityHeight - entityMargin.top - entityMargin.bottom, 0]);

    // Add tooltip
    const entityTooltip = d3.select(this.entityActivity.nativeElement).append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'white')
      .style('padding', '8px')
      .style('border', '1px solid #ddd')
      .style('border-radius', '4px')
      .style('pointer-events', 'none');

    entityG.selectAll('rect')
      .data(entities)
      .enter().append('rect')
      .attr('x', d => entityXScale(d[0]) || 0)
      .attr('y', d => entityYScale(d[1]))
      .attr('width', entityXScale.bandwidth())
      .attr('height', d => entityHeight - entityMargin.top - entityMargin.bottom - entityYScale(d[1]))
      .attr('fill', '#007acc')
      .on('mouseover', (event, d: any) => {
        entityTooltip.transition()
          .duration(200)
          .style('opacity', 1);
        entityTooltip.html(`
        <strong>${d[0]}</strong><br/>
        Events: ${d[1]}<br/>
        ${((d[1] / this.processedEvents.length) * 100).toFixed(1)}% of total
      `)
          .style('left', (event: any, data: any) => (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');

        d3.select(event.currentTarget)
          .attr('fill', '#005a9c');
      })
      .on('mousemove', (event) => {
        entityTooltip
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseout', (event, d) => {
        entityTooltip.transition()
          .duration(500)
          .style('opacity', 0);

        d3.select(event.currentTarget)
          .attr('fill', '#007acc');
      });

    entityG.append('g')
      .attr('transform', `translate(0,${entityHeight - entityMargin.top - entityMargin.bottom})`)
      .call(d3.axisBottom(entityXScale))
      .selectAll('text')
      .attr('transform', 'rotate(-45)')
      .style('text-anchor', 'end');

    entityG.append('g')
      .call(d3.axisLeft(entityYScale));
  }

  playStory() {
    this.storyPlaying = true;
    this.currentStoryIndex = -1;
    this.storyInterval = setInterval(() => {
      this.currentStoryIndex++;
      if (this.currentStoryIndex >= this.processedEvents.length) {
        this.pauseStory();
      }
    }, 2000);
  }

  pauseStory() {
    this.storyPlaying = false;
    clearInterval(this.storyInterval);
  }

  resetStory() {
    this.pauseStory();
    this.currentStoryIndex = -1;
  }

  // Animation control methods for circular timeline
  startCircularTimelineAnimation() {
    if (this.isAnimating) return;

    this.isAnimating = true;

    // Set animation date range
    const timeExtent = d3.extent(this.processedEvents, d => d.parsedDate) as [Date, Date];
    this.animationStartDate = timeExtent[0];
    this.animationEndDate = timeExtent[1];
    this.currentAnimationDate = new Date(this.animationStartDate);

    // Start the animation
    this.animationInterval = setInterval(() => {
      this.currentAnimationDate = new Date(this.currentAnimationDate!.getTime() + (24 * 60 * 60 * 1000)); // Add one day

      if (this.currentAnimationDate >= this.animationEndDate!) {
        this.pauseCircularTimelineAnimation();
        return;
      }

      this.renderCircularTimeline();
    }, this.animationSpeed);
  }

  pauseCircularTimelineAnimation() {
    this.isAnimating = false;
    if (this.animationInterval) {
      clearInterval(this.animationInterval);
      this.animationInterval = null;
    }
  }

  resetCircularTimelineAnimation() {
    this.pauseCircularTimelineAnimation();
    this.currentAnimationDate = null;
    this.renderCircularTimeline();
  }

  setAnimationSpeed(speed: number) {
    this.animationSpeed = speed;
    if (this.isAnimating) {
      this.pauseCircularTimelineAnimation();
      this.startCircularTimelineAnimation();
    }
  }

  onSpeedChange(event: Event) {
    const target = event.target as HTMLInputElement;
    this.setAnimationSpeed(+target.value);
  }
}


